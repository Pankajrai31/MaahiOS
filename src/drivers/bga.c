/**
 * BGA (Bochs Graphics Adapter) Driver
 * Platform-independent graphics driver for QEMU/Bochs/VirtualBox
 */

#include "bga.h"
#include <stdint.h>

/* Serial debug helpers */
static inline unsigned char inb(unsigned short port) {
    unsigned char ret;
    __asm__ volatile("inb %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

static inline void outb(unsigned short port, unsigned char val) {
    __asm__ volatile("outb %0, %1" : : "a"(val), "Nd"(port));
}

static void serial_print(const char *str) {
    while (*str) {
        while ((inb(0x3FD) & 0x20) == 0);
        outb(0x3F8, *str++);
    }
}

static void serial_hex(uint32_t value) {
    char hex[] = "0123456789ABCDEF";
    for (int i = 7; i >= 0; i--) {
        unsigned char nibble = (value >> (i * 4)) & 0xF;
        while ((inb(0x3FD) & 0x20) == 0);
        outb(0x3F8, hex[nibble]);
    }
}

/* Global state */
static uint32_t *framebuffer = 0;
static uint16_t screen_width = 0;
static uint16_t screen_height = 0;
static uint16_t screen_bpp = 0;
static int cursor_x = 0;
static int cursor_y = 0;

/**
 * Read a pixel from the framebuffer
 * Used by cursor compositor to save/restore background
 */
uint32_t bga_get_pixel(int x, int y) {
    if (!framebuffer || x < 0 || y < 0 || x >= screen_width || y >= screen_height) {
        return 0x000000;  // Black for out-of-bounds
    }
    return framebuffer[y * screen_width + x];
}

/* 8x16 VGA Font (same as VBE - for text rendering) */
static const uint8_t font_8x16[128][16] = {
    [0 ... 31] = {0},
    [32] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // Space
    [33] = {0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18,
            0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},  // !
    [48] = {0x00, 0x00, 0x3C, 0x66, 0x66, 0x6E, 0x76, 0x66,
            0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // 0
    [49] = {0x00, 0x00, 0x18, 0x38, 0x18, 0x18, 0x18, 0x18,
            0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00},  // 1
    [50] = {0x00, 0x00, 0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30,
            0x60, 0x66, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00},  // 2
    [65] = {0x00, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x7E,
            0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},  // A
    [66] = {0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x66,
            0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00},  // B
    [67] = {0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x60,
            0x60, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // C
    [68] = {0x00, 0x00, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66,
            0x66, 0x6C, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00},  // D
    [69] = {0x00, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60,
            0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00},  // E
    [72] = {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x7E, 0x66,
            0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},  // H
    [73] = {0x00, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18,
            0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00},  // I
    [76] = {0x00, 0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,
            0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00},  // L
    [77] = {0x00, 0x00, 0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63,
            0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00},  // M
    [79] = {0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66,
            0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // O
    [82] = {0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x6C,
            0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},  // R
    [83] = {0x00, 0x00, 0x3C, 0x66, 0x60, 0x30, 0x18, 0x0C,
            0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // S
    [84] = {0x00, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18,
            0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},  // T
    [85] = {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
            0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // U
    [86] = {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
            0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},  // V
    [87] = {0x00, 0x00, 0x63, 0x63, 0x63, 0x6B, 0x6B, 0x7F,
            0x77, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00},  // W
    [88] = {0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C,
            0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},  // X
    [89] = {0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18,
            0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},  // Y
    [90] = {0x00, 0x00, 0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60,
            0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00},  // Z
    [70] = {0x00, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60,
            0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},  // F
    [71] = {0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x6E, 0x66,
            0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // G
    [75] = {0x00, 0x00, 0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C,
            0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},  // K
    [78] = {0x00, 0x00, 0x66, 0x66, 0x76, 0x7E, 0x6E, 0x66,
            0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00},  // N
    [80] = {0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x60,
            0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},  // P
    [81] = {0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66,
            0x66, 0x3C, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00},  // Q
    [51] = {0x00, 0x00, 0x3C, 0x66, 0x06, 0x0C, 0x18, 0x0C,
            0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // 3
    [52] = {0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0x6C, 0x7E,
            0x0C, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00},  // 4
    [53] = {0x00, 0x00, 0x7E, 0x60, 0x60, 0x7C, 0x06, 0x06,
            0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // 5
    [54] = {0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x7C, 0x66,
            0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // 6
    [55] = {0x00, 0x00, 0x7E, 0x06, 0x0C, 0x0C, 0x18, 0x18,
            0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00},  // 7
    [56] = {0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x66,
            0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // 8
    [57] = {0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3E, 0x06,
            0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // 9
    [97] = {0x00, 0x00, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66,
            0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00},  // a
    [98] = {0x00, 0x00, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66,
            0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00},  // b
    [99] = {0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60,
            0x60, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},  // c
    [100] = {0x00, 0x00, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x66,
             0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00}, // d
    [101] = {0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x7E,
             0x60, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00}, // e
    [102] = {0x00, 0x00, 0x1E, 0x30, 0x30, 0x7C, 0x30, 0x30,
             0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00}, // f
    [103] = {0x00, 0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66,
             0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00}, // g
    [104] = {0x00, 0x00, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66,
             0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}, // h
    [105] = {0x00, 0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18,
             0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00}, // i
    [106] = {0x00, 0x00, 0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C,
             0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00, 0x00, 0x00}, // j
    [107] = {0x00, 0x00, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x70,
             0x78, 0x6C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}, // k
    [108] = {0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18,
             0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00}, // l
    [109] = {0x00, 0x00, 0x00, 0x00, 0x6C, 0x7E, 0x6B, 0x6B,
             0x6B, 0x6B, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x00}, // m
    [110] = {0x00, 0x00, 0x00, 0x00, 0x6C, 0x76, 0x66, 0x66,
             0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}, // n
    [111] = {0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66,
             0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00}, // o
    [112] = {0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66,
             0x66, 0x7C, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00}, // p
    [113] = {0x00, 0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66,
             0x66, 0x3E, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00}, // q
    [114] = {0x00, 0x00, 0x00, 0x00, 0x6C, 0x76, 0x60, 0x60,
             0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00}, // r (fixed)
    [115] = {0x00, 0x00, 0x00, 0x00, 0x3C, 0x60, 0x3C, 0x06,
             0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00}, // s
    [116] = {0x00, 0x00, 0x30, 0x30, 0x7C, 0x30, 0x30, 0x30,
             0x30, 0x30, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00}, // t
    [117] = {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,
             0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00}, // u
    [118] = {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,
             0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, // v
    [119] = {0x00, 0x00, 0x00, 0x00, 0x63, 0x63, 0x6B, 0x6B,
             0x6B, 0x7E, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // w
    [120] = {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3C, 0x18,
             0x3C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}, // x
    [121] = {0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,
             0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00}, // y
    [122] = {0x00, 0x00, 0x00, 0x00, 0x7E, 0x06, 0x0C, 0x18,
             0x30, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00}, // z
};

/* Port I/O functions */
static inline void outw(uint16_t port, uint16_t val) {
    __asm__ volatile("outw %0, %1" : : "a"(val), "Nd"(port));
}

static inline uint16_t inw(uint16_t port) {
    uint16_t ret;
    __asm__ volatile("inw %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

static inline void outl(uint16_t port, uint32_t val) {
    __asm__ volatile("outl %0, %1" : : "a"(val), "Nd"(port));
}

static inline uint32_t inl(uint16_t port) {
    uint32_t ret;
    __asm__ volatile("inl %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

/**
 * Write to BGA register
 */
void bga_write_register(uint16_t index, uint16_t value) {
    outw(VBE_DISPI_IOPORT_INDEX, index);
    outw(VBE_DISPI_IOPORT_DATA, value);
}

/**
 * Read from BGA register
 */
uint16_t bga_read_register(uint16_t index) {
    outw(VBE_DISPI_IOPORT_INDEX, index);
    return inw(VBE_DISPI_IOPORT_DATA);
}

/**
 * Check if BGA is available
 */
int bga_is_available(void) {
    uint16_t version = bga_read_register(VBE_DISPI_INDEX_ID);
    return (version >= VBE_DISPI_ID0 && version <= VBE_DISPI_ID5);
}

/**
 * Set video mode
 */
void bga_set_video_mode(uint16_t width, uint16_t height, uint16_t bpp) {
    // Disable VBE extensions
    bga_write_register(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_DISABLED);
    
    // Set resolution and bpp  
    bga_write_register(VBE_DISPI_INDEX_XRES, width);
    bga_write_register(VBE_DISPI_INDEX_YRES, height);
    bga_write_register(VBE_DISPI_INDEX_BPP, bpp);
    
    // Enable VBE extensions with linear framebuffer
    bga_write_register(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_ENABLED | VBE_DISPI_LFB_ENABLED);
}

/**
 * Simple PCI config read
 */
static uint32_t pci_read_config(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) {
    uint32_t address = (uint32_t)((bus << 16) | (slot << 11) | (func << 8) | (offset & 0xFC) | 0x80000000);
    outl(0xCF8, address);
    return inl(0xCFC);
}

/**
 * Get framebuffer address from PCI BAR0
 */
uint32_t bga_get_framebuffer_addr(void) {
    // Scan PCI bus for BGA device (0x1234:0x1111)
    for (uint8_t slot = 0; slot < 32; slot++) {
        uint32_t vendor_device = pci_read_config(0, slot, 0, 0x00);
        
        // Check if this is BGA device (vendor 0x1234, device 0x1111)
        if (vendor_device == 0x11111234) {
            // Found it! Read BAR0
            uint32_t bar0 = pci_read_config(0, slot, 0, 0x10);
            
            if (bar0 != 0 && bar0 != 0xFFFFFFFF) {
                return bar0 & 0xFFFFFFF0;  // Mask off lower bits
            }
        }
    }
    
    // Fallback to default address if device not found
    return 0xFD000000;  // QEMU Q35 typical address
}

/**
 * Get framebuffer size
 */
uint32_t bga_get_framebuffer_size(void) {
    return screen_width * screen_height * (screen_bpp / 8);
}

/**
 * Get screen width
 */
uint16_t bga_get_width(void) {
    return screen_width;
}

/**
 * Get screen height
 */
uint16_t bga_get_height(void) {
    return screen_height;
}

/**
 * Initialize BGA driver
 */
int bga_init(uint16_t width, uint16_t height, uint16_t bpp) {
    if (!bga_is_available()) {
        return 0;  // BGA not available
    }
    
    // Set video mode
    bga_set_video_mode(width, height, bpp);
    
    // Verify the mode was set by reading back
    uint16_t actual_width = bga_read_register(VBE_DISPI_INDEX_XRES);
    uint16_t actual_height = bga_read_register(VBE_DISPI_INDEX_YRES);
    uint16_t actual_bpp = bga_read_register(VBE_DISPI_INDEX_BPP);
    
    // Save actual parameters
    screen_width = actual_width;
    screen_height = actual_height;
    screen_bpp = actual_bpp;
    
    // Get framebuffer address
    framebuffer = (uint32_t *)bga_get_framebuffer_addr();
    
    cursor_x = 0;
    cursor_y = 0;
    
    return 1;  // Success
}

/**
 * Clear screen
 */
void bga_clear(uint32_t color) {
    if (!framebuffer) return;
    
    uint32_t pixels = screen_width * screen_height;
    for (uint32_t i = 0; i < pixels; i++) {
        framebuffer[i] = color & 0x00FFFFFF;  // Strip alpha byte
    }
}

/**
 * Put pixel
 */
void bga_putpixel(int x, int y, uint32_t color) {
    if (!framebuffer) return;
    if (x < 0 || x >= screen_width || y < 0 || y >= screen_height) return;
    
    framebuffer[y * screen_width + x] = color & 0x00FFFFFF;  // Strip alpha byte
}

/**
 * Draw character
 */
static void bga_putchar(int x, int y, char c, uint32_t fg, uint32_t bg) {
    uint8_t uc = (uint8_t)c;
    if (uc >= 128) uc = 0;
    
    const uint8_t *glyph = font_8x16[uc];
    
    for (int row = 0; row < 16; row++) {
        uint8_t line = glyph[row];
        for (int col = 0; col < 8; col++) {
            // Only draw foreground pixels if bit is set, skip background (transparent)
            if (line & (0x80 >> col)) {
                bga_putpixel(x + col, y + row, fg);
            }
        }
    }
}

/**
 * Print string at current cursor position
 */
void bga_print(const char *str, uint32_t fg, uint32_t bg) {
    if (!framebuffer) return;
    
    while (*str) {
        if (*str == '\n') {
            cursor_x = 0;
            cursor_y += 16;
            if (cursor_y >= screen_height) {
                cursor_y = 0;  // Wrap to top (simple for now)
            }
            str++;
            continue;
        }
        
        bga_putchar(cursor_x, cursor_y, *str, fg, bg);
        cursor_x += 8;
        
        if (cursor_x + 8 > screen_width) {
            cursor_x = 0;
            cursor_y += 16;
            if (cursor_y >= screen_height) {
                cursor_y = 0;
            }
        }
        
        str++;
    }
}

/**
 * Print string at specific position (doesn't update cursor)
 */
void bga_print_at(int x, int y, const char *str, uint32_t fg, uint32_t bg) {
    if (!framebuffer) return;
    
    int pos_x = x;
    int pos_y = y;
    
    while (*str) {
        if (*str == '\n') {
            pos_x = x;
            pos_y += 16;
            str++;
            continue;
        }
        
        bga_putchar(pos_x, pos_y, *str, fg, bg);
        pos_x += 8;
        
        if (pos_x + 8 > screen_width) {
            pos_x = x;
            pos_y += 16;
        }
        
        str++;
    }
}

/**
 * Set cursor position
 */
void bga_set_cursor(int x, int y) {
    cursor_x = x;
    cursor_y = y;
}

/**
 * Get cursor position
 */
void bga_get_cursor(int *x, int *y) {
    if (x) *x = cursor_x;
    if (y) *y = cursor_y;
}

/**
 * Fill a rectangle with solid color
 */
void bga_fill_rect(int x, int y, int width, int height, uint32_t color) {
    if (!framebuffer) return;
    
    // Strip alpha byte if present
    uint32_t rgb_color = color & 0x00FFFFFF;
    
    for (int row = y; row < y + height && row < screen_height; row++) {
        for (int col = x; col < x + width && col < screen_width; col++) {
            if (row >= 0 && col >= 0) {
                framebuffer[row * screen_width + col] = rgb_color;
            }
        }
    }
}

/**
 * Draw a rectangle outline
 */
void bga_draw_rect(int x, int y, int width, int height, uint32_t color) {
    if (!framebuffer) return;
    
    // Top and bottom lines
    for (int col = x; col < x + width && col < screen_width; col++) {
        if (col >= 0) {
            if (y >= 0 && y < screen_height) bga_putpixel(col, y, color);
            if (y + height - 1 >= 0 && y + height - 1 < screen_height) 
                bga_putpixel(col, y + height - 1, color);
        }
    }
    
    // Left and right lines
    for (int row = y; row < y + height && row < screen_height; row++) {
        if (row >= 0) {
            if (x >= 0 && x < screen_width) bga_putpixel(x, row, color);
            if (x + width - 1 >= 0 && x + width - 1 < screen_width) 
                bga_putpixel(x + width - 1, row, color);
        }
    }
}

/**
 * Draw BMP image from memory
 * Supports 32-bit BMP files only
 */
void bga_draw_bmp(int x, int y, const uint8_t *bmp_data) {
    if (!framebuffer || !bmp_data) {
        serial_print("[BMP] NULL pointer\n");
        return;
    }
    
    // Debug: Print first few bytes
    serial_print("[BMP] Data at 0x");
    serial_hex((uint32_t)bmp_data);
    serial_print(" bytes: 0x");
    serial_hex(bmp_data[0]);
    serial_print(" 0x");
    serial_hex(bmp_data[1]);
    serial_print("\n");
    
    // Verify BMP signature (should be 'BM')
    if (bmp_data[0] != 0x42 || bmp_data[1] != 0x4D) {
        // Invalid BMP - just draw a red square to show error
        serial_print("[BMP] Invalid signature!\n");
        bga_fill_rect(x, y, 32, 32, 0xFF0000);
        return;
    }
    
    serial_print("[BMP] Valid signature, drawing...\n");
    
    // Parse BMP header to get dimensions
    // Offset 18: width (4 bytes, little-endian)
    // Offset 22: height (4 bytes, little-endian)
    uint32_t width = bmp_data[18] | (bmp_data[19] << 8) | (bmp_data[20] << 16) | (bmp_data[21] << 24);
    uint32_t height = bmp_data[22] | (bmp_data[23] << 8) | (bmp_data[24] << 16) | (bmp_data[25] << 24);
    
    // Sanity check dimensions (our icons are 32x32)
    if (width > 128 || height > 128 || width == 0 || height == 0) {
        // Invalid dimensions - draw yellow square
        bga_fill_rect(x, y, 32, 32, 0xFFFF00);
        return;
    }
    
    // Pixel data starts at offset 54 for our 32-bit BMPs
    const uint8_t *pixel_data = bmp_data + 54;
    
    // BMP stores pixels bottom-to-top, so we need to flip vertically
    for (uint32_t row = 0; row < height; row++) {
        for (uint32_t col = 0; col < width; col++) {
            // Calculate index in BMP data (bottom-to-top)
            uint32_t bmp_row = height - 1 - row;
            uint32_t pixel_index = (bmp_row * width + col) * 4;
            
            uint8_t b = pixel_data[pixel_index + 0];
            uint8_t g = pixel_data[pixel_index + 1];
            uint8_t r = pixel_data[pixel_index + 2];
            uint8_t a = pixel_data[pixel_index + 3];
            
            // Skip transparent pixels (alpha == 0)
            if (a == 0) continue;
            
            // Draw pixel as RGB (strip alpha)
            uint32_t color = (r << 16) | (g << 8) | b;
            bga_putpixel(x + col, y + row, color);
        }
    }
}
